<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/AlexGilleran/jsx-control-statements#readme">jsx-control-statements (v3.1.5)</a>
</h1>
<h4>Neater control statements (if/for) for jsx</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsx-control-statements">module jsx-control-statements</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsx-control-statements.jsx-control-statements">
            function <span class="apidocSignatureSpan"></span>jsx-control-statements
            <span class="apidocSignatureSpan">(babel)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsx-control-statements.</span>ast</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsx-control-statements.</span>conditional</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsx-control-statements.</span>error</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsx-control-statements.ast">module jsx-control-statements.ast</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsx-control-statements.ast.addKeyAttribute">
            function <span class="apidocSignatureSpan">jsx-control-statements.ast.</span>addKeyAttribute
            <span class="apidocSignatureSpan">(babelTypes, node, keyValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsx-control-statements.ast.getAttributeMap">
            function <span class="apidocSignatureSpan">jsx-control-statements.ast.</span>getAttributeMap
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsx-control-statements.ast.getChildren">
            function <span class="apidocSignatureSpan">jsx-control-statements.ast.</span>getChildren
            <span class="apidocSignatureSpan">(babelTypes, node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsx-control-statements.ast.getExpression">
            function <span class="apidocSignatureSpan">jsx-control-statements.ast.</span>getExpression
            <span class="apidocSignatureSpan">(attribute)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsx-control-statements.ast.getKey">
            function <span class="apidocSignatureSpan">jsx-control-statements.ast.</span>getKey
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsx-control-statements.ast.getSanitizedExpressionForContent">
            function <span class="apidocSignatureSpan">jsx-control-statements.ast.</span>getSanitizedExpressionForContent
            <span class="apidocSignatureSpan">(babelTypes, blocks, keyPrefix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsx-control-statements.ast.isExpressionContainer">
            function <span class="apidocSignatureSpan">jsx-control-statements.ast.</span>isExpressionContainer
            <span class="apidocSignatureSpan">(attribute)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsx-control-statements.ast.isStringLiteral">
            function <span class="apidocSignatureSpan">jsx-control-statements.ast.</span>isStringLiteral
            <span class="apidocSignatureSpan">(attribute)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsx-control-statements.ast.isTag">
            function <span class="apidocSignatureSpan">jsx-control-statements.ast.</span>isTag
            <span class="apidocSignatureSpan">(node, tagName)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsx-control-statements.conditional">module jsx-control-statements.conditional</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsx-control-statements.conditional.getConditionExpression">
            function <span class="apidocSignatureSpan">jsx-control-statements.conditional.</span>getConditionExpression
            <span class="apidocSignatureSpan">(node, errorInfos)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsx-control-statements.error">module jsx-control-statements.error</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsx-control-statements.error.renderErrorMessage">
            function <span class="apidocSignatureSpan">jsx-control-statements.error.</span>renderErrorMessage
            <span class="apidocSignatureSpan">(errorMsg, infos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsx-control-statements.error.throwChooseOtherwiseNotLast">
            function <span class="apidocSignatureSpan">jsx-control-statements.error.</span>throwChooseOtherwiseNotLast
            <span class="apidocSignatureSpan">(infos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsx-control-statements.error.throwChooseWithMultipleOtherwise">
            function <span class="apidocSignatureSpan">jsx-control-statements.error.</span>throwChooseWithMultipleOtherwise
            <span class="apidocSignatureSpan">(infos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsx-control-statements.error.throwChooseWithWrongChildren">
            function <span class="apidocSignatureSpan">jsx-control-statements.error.</span>throwChooseWithWrongChildren
            <span class="apidocSignatureSpan">(infos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsx-control-statements.error.throwChooseWithoutWhen">
            function <span class="apidocSignatureSpan">jsx-control-statements.error.</span>throwChooseWithoutWhen
            <span class="apidocSignatureSpan">(infos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsx-control-statements.error.throwNoAttribute">
            function <span class="apidocSignatureSpan">jsx-control-statements.error.</span>throwNoAttribute
            <span class="apidocSignatureSpan">(attributeName, infos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsx-control-statements.error.throwNotExpressionType">
            function <span class="apidocSignatureSpan">jsx-control-statements.error.</span>throwNotExpressionType
            <span class="apidocSignatureSpan">(attributeName, infos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsx-control-statements.error.throwNotStringType">
            function <span class="apidocSignatureSpan">jsx-control-statements.error.</span>throwNotStringType
            <span class="apidocSignatureSpan">(attributeName, infos)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsx-control-statements.error.</span>ERRORS</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsx-control-statements" id="apidoc.module.jsx-control-statements">module jsx-control-statements</a></h1>


    <h2>
        <a href="#apidoc.element.jsx-control-statements.jsx-control-statements" id="apidoc.element.jsx-control-statements.jsx-control-statements">
        function <span class="apidocSignatureSpan"></span>jsx-control-statements
        <span class="apidocSignatureSpan">(babel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function jcsPlugin(babel) {
  var nodeHandlers = {
    For: transformFor(babel),
    If: transformIf(babel),
    Choose: transformChoose(babel)
  };

  var visitor = {
    JSXElement: function(path) {
      var nodeName = path.node.openingElement.name.name;
      var handler = nodeHandlers[nodeName];

      if (handler) {
        path.replaceWith(handler(path.node, path.hub.file));
      }
    }
  };

  return {
    inherits: require("babel-plugin-syntax-jsx"),
    visitor: visitor
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsx-control-statements.ast" id="apidoc.module.jsx-control-statements.ast">module jsx-control-statements.ast</a></h1>


    <h2>
        <a href="#apidoc.element.jsx-control-statements.ast.addKeyAttribute" id="apidoc.element.jsx-control-statements.ast.addKeyAttribute">
        function <span class="apidocSignatureSpan">jsx-control-statements.ast.</span>addKeyAttribute
        <span class="apidocSignatureSpan">(babelTypes, node, keyValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addKeyAttribute = function (babelTypes, node, keyValue) {
  var keyFound = false;

  node.openingElement.attributes.forEach(function(attrib) {
    if (babelTypes.isJSXAttribute(attrib) &amp;&amp; attrib.name.name === "key") {
      keyFound = true;
      return false;
    }
  });

  if (!keyFound) {
    var keyAttrib = babelTypes.jSXAttribute(babelTypes.jSXIdentifier("key"), babelTypes.stringLiteral("" + keyValue));
    node.openingElement.attributes.push(keyAttrib);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsx-control-statements.ast.getAttributeMap" id="apidoc.element.jsx-control-statements.ast.getAttributeMap">
        function <span class="apidocSignatureSpan">jsx-control-statements.ast.</span>getAttributeMap
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAttributeMap = function (node) {
  return node.openingElement.attributes.reduce(function(result, attr) {
    result[attr.name.name] = attr;
    return result;
  }, {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

module.exports = function(babel) {
  var types = babel.types;

  return function(node, file) {
var mapParams = [];
var errorInfos = { node: node, file: file, element: ELEMENTS.FOR };
var attributes = astUtil.<span class="apidocCodeKeywordSpan">getAttributeMap</span>(node);
var children = astUtil.getChildren(types, node);
var returnExpression = astUtil.getSanitizedExpressionForContent(types, children);

// required attribute
if (!attributes[ATTRIBUTES.OF]) {
  errorUtil.throwNoAttribute(ATTRIBUTES.OF, errorInfos);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsx-control-statements.ast.getChildren" id="apidoc.element.jsx-control-statements.ast.getChildren">
        function <span class="apidocSignatureSpan">jsx-control-statements.ast.</span>getChildren
        <span class="apidocSignatureSpan">(babelTypes, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getChildren = function (babelTypes, node) {
  return babelTypes.react.buildChildren(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function getBlocks(types, children, errorInfos, key) {
  var childNodes;
  var startResult = {};
  startResult[ELEMENTS.WHEN] = [];

  var result = children.reduceRight(function(resultSoFar, child) {
    if (astUtil.isTag(child, ELEMENTS.OTHERWISE)) {
childNodes = astUtil.<span class="apidocCodeKeywordSpan">getChildren</span>(types, child);
errorInfos.element = ELEMENTS.OTHERWISE;
errorInfos.node = child;

if (resultSoFar[ELEMENTS.WHEN].length) {
  errorUtil.throwChooseOtherwiseNotLast(errorInfos);
}
else if (resultSoFar[ELEMENTS.OTHERWISE]) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsx-control-statements.ast.getExpression" id="apidoc.element.jsx-control-statements.ast.getExpression">
        function <span class="apidocSignatureSpan">jsx-control-statements.ast.</span>getExpression
        <span class="apidocSignatureSpan">(attribute)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getExpression = function (attribute) {
  return attribute.value.expression;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (!condition) {
    errorUtil.throwNoAttribute(ATTRIBUTES.CONDITION, errorInfos);
  }
  if (!astUtil.isExpressionContainer(condition)) {
    errorUtil.throwNotExpressionType(ATTRIBUTES.CONDITION, errorInfos);
  }

  return astUtil.<span class="apidocCodeKeywordSpan">getExpression</span>(condition);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsx-control-statements.ast.getKey" id="apidoc.element.jsx-control-statements.ast.getKey">
        function <span class="apidocSignatureSpan">jsx-control-statements.ast.</span>getKey
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getKey = function (node) {
  var key = exports.getAttributeMap(node).key;
  return key ? key.value.value : undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

module.exports = function(babel) {
  var types = babel.types;

  return function(node, file) {
var errorInfos = { node: node, file: file, element: ELEMENTS.CHOOSE };
var children = astUtil.getChildren(types, node);
var key = astUtil.<span class="apidocCodeKeywordSpan">getKey</span>(node);
var blocks = getBlocks(types, children, errorInfos, key);
var ternaryExpression = blocks[ELEMENTS.OTHERWISE];

if (!blocks[ELEMENTS.WHEN].length) {
  errorInfos.node = node;
  errorUtil.throwChooseWithoutWhen(errorInfos);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsx-control-statements.ast.getSanitizedExpressionForContent" id="apidoc.element.jsx-control-statements.ast.getSanitizedExpressionForContent">
        function <span class="apidocSignatureSpan">jsx-control-statements.ast.</span>getSanitizedExpressionForContent
        <span class="apidocSignatureSpan">(babelTypes, blocks, keyPrefix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSanitizedExpressionForContent = function (babelTypes, blocks, keyPrefix) {
  if (!blocks.length) {
    return babelTypes.NullLiteral();
  }
  else if (blocks.length === 1) {
    var firstBlock = blocks[0];

    if (keyPrefix &amp;&amp; firstBlock.openingElement) {
      addKeyAttribute(babelTypes, firstBlock, keyPrefix);
    }

    return firstBlock;
  }

  for (var i = 0; i &lt; blocks.length; i++) {
    var thisBlock = blocks[i];
    if (babelTypes.isJSXElement(thisBlock)) {
      var key = keyPrefix ? keyPrefix + "-" + i : i;
      addKeyAttribute(babelTypes, thisBlock, key);
    }
  }

  return babelTypes.arrayExpression(blocks);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (resultSoFar[ELEMENTS.WHEN].length) {
  errorUtil.throwChooseOtherwiseNotLast(errorInfos);
}
else if (resultSoFar[ELEMENTS.OTHERWISE]) {
  errorUtil.throwChooseWithMultipleOtherwise(errorInfos);
}

resultSoFar[ELEMENTS.OTHERWISE] = astUtil.<span class="apidocCodeKeywordSpan">getSanitizedExpressionForContent</span>(types, childNodes
, key);
    }
    else if (astUtil.isTag(child, ELEMENTS.WHEN)) {
childNodes = astUtil.getChildren(types, child);
errorInfos.element = ELEMENTS.WHEN;
errorInfos.node = child;

resultSoFar[ELEMENTS.WHEN].push({
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsx-control-statements.ast.isExpressionContainer" id="apidoc.element.jsx-control-statements.ast.isExpressionContainer">
        function <span class="apidocSignatureSpan">jsx-control-statements.ast.</span>isExpressionContainer
        <span class="apidocSignatureSpan">(attribute)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isExpressionContainer = function (attribute) {
  return attribute &amp;&amp; attribute.value.type === TYPES.EXPRESSION_CONTAINER;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function checkForString(attributes, name, errorInfos) {
if (attributes[name] &amp;&amp; !astUtil.isStringLiteral(attributes[name])) {
  errorUtil.throwNotStringType(name, errorInfos);
}
}

function checkForExpression(attributes, name, errorInfos) {
if (attributes[name] &amp;&amp; !astUtil.<span class="apidocCodeKeywordSpan">isExpressionContainer</span>(attributes[name])) {
  errorUtil.throwNotExpressionType(name, errorInfos);
}
}

module.exports = function(babel) {
var types = babel.types;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsx-control-statements.ast.isStringLiteral" id="apidoc.element.jsx-control-statements.ast.isStringLiteral">
        function <span class="apidocSignatureSpan">jsx-control-statements.ast.</span>isStringLiteral
        <span class="apidocSignatureSpan">(attribute)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isStringLiteral = function (attribute) {
  return attribute &amp;&amp; attribute.value.type === TYPES.STRING_LITERAL;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
else {
  params.push(types.Identifier(attributeKey));
}
}

function checkForString(attributes, name, errorInfos) {
if (attributes[name] &amp;&amp; !astUtil.<span class="apidocCodeKeywordSpan">isStringLiteral</span>(attributes[name])) {
  errorUtil.throwNotStringType(name, errorInfos);
}
}

function checkForExpression(attributes, name, errorInfos) {
if (attributes[name] &amp;&amp; !astUtil.isExpressionContainer(attributes[name])) {
  errorUtil.throwNotExpressionType(name, errorInfos);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsx-control-statements.ast.isTag" id="apidoc.element.jsx-control-statements.ast.isTag">
        function <span class="apidocSignatureSpan">jsx-control-statements.ast.</span>isTag
        <span class="apidocSignatureSpan">(node, tagName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isTag = function (node, tagName) {
  return node.type === TYPES.ELEMENT &amp;&amp; getTagName(node) === tagName;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function getBlocks(types, children, errorInfos, key) {
  var childNodes;
  var startResult = {};
  startResult[ELEMENTS.WHEN] = [];

  var result = children.reduceRight(function(resultSoFar, child) {
    if (astUtil.<span class="apidocCodeKeywordSpan">isTag</span>(child, ELEMENTS.OTHERWISE)) {
childNodes = astUtil.getChildren(types, child);
errorInfos.element = ELEMENTS.OTHERWISE;
errorInfos.node = child;

if (resultSoFar[ELEMENTS.WHEN].length) {
  errorUtil.throwChooseOtherwiseNotLast(errorInfos);
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsx-control-statements.conditional" id="apidoc.module.jsx-control-statements.conditional">module jsx-control-statements.conditional</a></h1>


    <h2>
        <a href="#apidoc.element.jsx-control-statements.conditional.getConditionExpression" id="apidoc.element.jsx-control-statements.conditional.getConditionExpression">
        function <span class="apidocSignatureSpan">jsx-control-statements.conditional.</span>getConditionExpression
        <span class="apidocSignatureSpan">(node, errorInfos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getConditionExpression = function (node, errorInfos) {
  var condition = astUtil.getAttributeMap(node)[ATTRIBUTES.CONDITION];

  if (!condition) {
    errorUtil.throwNoAttribute(ATTRIBUTES.CONDITION, errorInfos);
  }
  if (!astUtil.isExpressionContainer(condition)) {
    errorUtil.throwNotExpressionType(ATTRIBUTES.CONDITION, errorInfos);
  }

  return astUtil.getExpression(condition);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
else if (astUtil.isTag(child, ELEMENTS.WHEN)) {
  childNodes = astUtil.getChildren(types, child);
  errorInfos.element = ELEMENTS.WHEN;
  errorInfos.node = child;

  resultSoFar[ELEMENTS.WHEN].push({
    condition: conditionalUtil.<span class="apidocCodeKeywordSpan">getConditionExpression</span>(child, errorInfos),
    children: astUtil.getSanitizedExpressionForContent(types, childNodes, key)
  });
}
else {
  errorInfos.element = ELEMENTS.CHOOSE;
  errorInfos.node = child;
  errorUtil.throwChooseWithWrongChildren(errorInfos);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsx-control-statements.error" id="apidoc.module.jsx-control-statements.error">module jsx-control-statements.error</a></h1>


    <h2>
        <a href="#apidoc.element.jsx-control-statements.error.renderErrorMessage" id="apidoc.element.jsx-control-statements.error.renderErrorMessage">
        function <span class="apidocSignatureSpan">jsx-control-statements.error.</span>renderErrorMessage
        <span class="apidocSignatureSpan">(errorMsg, infos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">renderErrorMessage = function (errorMsg, infos) {
  var args = [];
  if (infos) {
    args.push(infos.attribute);
    args.push(infos.element);
  }
  return formatString(errorMsg, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return typeof args[number] !== "undefined" ? args[number] : match;
});
}

function throwError(errorMsg, infos) {
throw new Error(
  [
    exports.<span class="apidocCodeKeywordSpan">renderErrorMessage</span>(errorMsg, infos),
    " at ",
    infos.file.opts.filename,
    ": ",
    infos.node.loc.start.line,
    ",",
    infos.node.loc.start.column
  ].join("")
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsx-control-statements.error.throwChooseOtherwiseNotLast" id="apidoc.element.jsx-control-statements.error.throwChooseOtherwiseNotLast">
        function <span class="apidocSignatureSpan">jsx-control-statements.error.</span>throwChooseOtherwiseNotLast
        <span class="apidocSignatureSpan">(infos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">throwChooseOtherwiseNotLast = function (infos) {
  throwError(ERRORS.CHOOSE_OTHERWISE_NOT_LAST, infos);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var result = children.reduceRight(function(resultSoFar, child) {
if (astUtil.isTag(child, ELEMENTS.OTHERWISE)) {
  childNodes = astUtil.getChildren(types, child);
  errorInfos.element = ELEMENTS.OTHERWISE;
  errorInfos.node = child;

  if (resultSoFar[ELEMENTS.WHEN].length) {
    errorUtil.<span class="apidocCodeKeywordSpan">throwChooseOtherwiseNotLast</span>(errorInfos);
  }
  else if (resultSoFar[ELEMENTS.OTHERWISE]) {
    errorUtil.throwChooseWithMultipleOtherwise(errorInfos);
  }

  resultSoFar[ELEMENTS.OTHERWISE] = astUtil.getSanitizedExpressionForContent(types, childNodes, key);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsx-control-statements.error.throwChooseWithMultipleOtherwise" id="apidoc.element.jsx-control-statements.error.throwChooseWithMultipleOtherwise">
        function <span class="apidocSignatureSpan">jsx-control-statements.error.</span>throwChooseWithMultipleOtherwise
        <span class="apidocSignatureSpan">(infos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">throwChooseWithMultipleOtherwise = function (infos) {
  throwError(ERRORS.CHOOSE_WITH_MULTIPLE_OTHERWISE, infos);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  errorInfos.element = ELEMENTS.OTHERWISE;
  errorInfos.node = child;

  if (resultSoFar[ELEMENTS.WHEN].length) {
    errorUtil.throwChooseOtherwiseNotLast(errorInfos);
  }
  else if (resultSoFar[ELEMENTS.OTHERWISE]) {
    errorUtil.<span class="apidocCodeKeywordSpan">throwChooseWithMultipleOtherwise</span>(errorInfos);
  }

  resultSoFar[ELEMENTS.OTHERWISE] = astUtil.getSanitizedExpressionForContent(types, childNodes, key);
}
else if (astUtil.isTag(child, ELEMENTS.WHEN)) {
  childNodes = astUtil.getChildren(types, child);
  errorInfos.element = ELEMENTS.WHEN;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsx-control-statements.error.throwChooseWithWrongChildren" id="apidoc.element.jsx-control-statements.error.throwChooseWithWrongChildren">
        function <span class="apidocSignatureSpan">jsx-control-statements.error.</span>throwChooseWithWrongChildren
        <span class="apidocSignatureSpan">(infos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">throwChooseWithWrongChildren = function (infos) {
  throwError(ERRORS.CHOOSE_WITH_WRONG_CHILDREN, infos);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      condition: conditionalUtil.getConditionExpression(child, errorInfos),
      children: astUtil.getSanitizedExpressionForContent(types, childNodes, key)
    });
  }
  else {
    errorInfos.element = ELEMENTS.CHOOSE;
    errorInfos.node = child;
    errorUtil.<span class="apidocCodeKeywordSpan">throwChooseWithWrongChildren</span>(errorInfos);
  }

  return resultSoFar;
}, startResult);

if (!result[ELEMENTS.OTHERWISE]) {
  result[ELEMENTS.OTHERWISE] = types.NullLiteral();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsx-control-statements.error.throwChooseWithoutWhen" id="apidoc.element.jsx-control-statements.error.throwChooseWithoutWhen">
        function <span class="apidocSignatureSpan">jsx-control-statements.error.</span>throwChooseWithoutWhen
        <span class="apidocSignatureSpan">(infos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">throwChooseWithoutWhen = function (infos) {
  throwError(ERRORS.CHOOSE_WITHOUT_WHEN, infos);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var children = astUtil.getChildren(types, node);
var key = astUtil.getKey(node);
var blocks = getBlocks(types, children, errorInfos, key);
var ternaryExpression = blocks[ELEMENTS.OTHERWISE];

if (!blocks[ELEMENTS.WHEN].length) {
  errorInfos.node = node;
  errorUtil.<span class="apidocCodeKeywordSpan">throwChooseWithoutWhen</span>(errorInfos);
}

blocks[ELEMENTS.WHEN].forEach(function(whenBlock) {
  ternaryExpression = types.ConditionalExpression(whenBlock.condition, whenBlock.children, ternaryExpression);
});

return ternaryExpression;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsx-control-statements.error.throwNoAttribute" id="apidoc.element.jsx-control-statements.error.throwNoAttribute">
        function <span class="apidocSignatureSpan">jsx-control-statements.error.</span>throwNoAttribute
        <span class="apidocSignatureSpan">(attributeName, infos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">throwNoAttribute = function (attributeName, infos) {
  infos.attribute = attributeName;
  throwError(ERRORS.NO_ATTRIBUTE, infos);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var errorInfos = { node: node, file: file, element: ELEMENTS.FOR };
var attributes = astUtil.getAttributeMap(node);
var children = astUtil.getChildren(types, node);
var returnExpression = astUtil.getSanitizedExpressionForContent(types, children);

// required attribute
if (!attributes[ATTRIBUTES.OF]) {
  errorUtil.<span class="apidocCodeKeywordSpan">throwNoAttribute</span>(ATTRIBUTES.OF, errorInfos);
}
// check for correct data types, as far as possible
checkForExpression(attributes, ATTRIBUTES.OF, errorInfos);
checkForString(attributes, ATTRIBUTES.EACH, errorInfos);
checkForString(attributes, ATTRIBUTES.INDEX, errorInfos);

// simply return without any child nodes
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsx-control-statements.error.throwNotExpressionType" id="apidoc.element.jsx-control-statements.error.throwNotExpressionType">
        function <span class="apidocSignatureSpan">jsx-control-statements.error.</span>throwNotExpressionType
        <span class="apidocSignatureSpan">(attributeName, infos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">throwNotExpressionType = function (attributeName, infos) {
  infos.attribute = attributeName;
  throwError(ERRORS.NOT_EXPRESSION_TYPE, infos);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (attributes[name] &amp;&amp; !astUtil.isStringLiteral(attributes[name])) {
  errorUtil.throwNotStringType(name, errorInfos);
}
}

function checkForExpression(attributes, name, errorInfos) {
if (attributes[name] &amp;&amp; !astUtil.isExpressionContainer(attributes[name])) {
  errorUtil.<span class="apidocCodeKeywordSpan">throwNotExpressionType</span>(name, errorInfos);
}
}

module.exports = function(babel) {
var types = babel.types;

return function(node, file) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsx-control-statements.error.throwNotStringType" id="apidoc.element.jsx-control-statements.error.throwNotStringType">
        function <span class="apidocSignatureSpan">jsx-control-statements.error.</span>throwNotStringType
        <span class="apidocSignatureSpan">(attributeName, infos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">throwNotStringType = function (attributeName, infos) {
  infos.attribute = attributeName;
  throwError(ERRORS.NOT_STRING_TYPE, infos);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
else {
  params.push(types.Identifier(attributeKey));
}
}

function checkForString(attributes, name, errorInfos) {
if (attributes[name] &amp;&amp; !astUtil.isStringLiteral(attributes[name])) {
  errorUtil.<span class="apidocCodeKeywordSpan">throwNotStringType</span>(name, errorInfos);
}
}

function checkForExpression(attributes, name, errorInfos) {
if (attributes[name] &amp;&amp; !astUtil.isExpressionContainer(attributes[name])) {
  errorUtil.throwNotExpressionType(name, errorInfos);
}
...</pre></li>
    </ul>




</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>